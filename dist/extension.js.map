{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://wot-ui-intellisense/./src/providers/component-factory.ts","webpack://wot-ui-intellisense/./src/utils/component_map.ts","webpack://wot-ui-intellisense/./src/utils/index.ts","webpack://wot-ui-intellisense/external commonjs \"vscode\"","webpack://wot-ui-intellisense/./src/utils/schema-loader.ts","webpack://wot-ui-intellisense/./src/providers/index.ts","webpack://wot-ui-intellisense/external node-commonjs \"fs\"","webpack://wot-ui-intellisense/./src/utils/markdown-parser.ts","webpack://wot-ui-intellisense/external node-commonjs \"path\"","webpack://wot-ui-intellisense/webpack/bootstrap","webpack://wot-ui-intellisense/./src/extension.ts"],"sourcesContent":["import * as vscode from 'vscode';\nimport { ComponentMeta } from '../utils/schema-loader';\nimport { ComponentCompletionProvider, ComponentHoverProvider, ComponentDiagnosticProvider } from './../utils/index';\n\n/**\n * 通用组件完成项提供者\n */\nexport class GenericComponentCompletionProvider extends ComponentCompletionProvider {\n  protected componentName: string;\n  protected componentMeta: ComponentMeta;\n  \n  constructor(componentName: string, componentMeta: ComponentMeta) {\n    super();\n    this.componentName = componentName;\n    this.componentMeta = componentMeta;\n  }\n\n  protected getTagSnippet(isKebab = true): vscode.SnippetString {\n    const tagName = isKebab ? this.componentName : this.componentName.replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n    return new vscode.SnippetString(`${tagName}$0></${tagName}>`);\n  }\n}\n\n/**\n * 通用组件悬停提供者\n */\nexport class GenericComponentHoverProvider extends ComponentHoverProvider {\n  protected componentName: string;\n  protected componentMeta: ComponentMeta;\n  \n  constructor(componentName: string, componentMeta: ComponentMeta) {\n    super();\n    this.componentName = componentName;\n    this.componentMeta = componentMeta;\n  }\n}\n\n/**\n * 通用组件诊断提供者\n */\nexport class GenericComponentDiagnosticProvider extends ComponentDiagnosticProvider {\n  protected componentName: string;\n  protected componentMeta: ComponentMeta;\n  \n  constructor(componentName: string, componentMeta: ComponentMeta) {\n    super();\n    this.componentName = componentName;\n    this.componentMeta = componentMeta;\n  }\n\n  protected getAdditionalDiagnostics?(tag: string, range: vscode.Range, diagnostics: vscode.Diagnostic[]): void {\n    // 默认实现不添加额外诊断\n  }\n}","import * as vscode from 'vscode';\r\nimport { loadComponentSchema } from './schema-loader';\r\nimport { GenericComponentCompletionProvider, GenericComponentHoverProvider } from '../providers/component-factory';\r\n\r\ninterface ComponentConfig {\r\n  tag: string;\r\n  module?: string;\r\n  triggers?: string[];\r\n  docSource?: string; // 添加文档来源字段\r\n}\r\n\r\n// 组件映射表\r\nexport const COMPONENT_MAP: ComponentConfig[] = [\r\n  { tag: 'wd-action-sheet'},\r\n  { tag: 'wd-backtop'},\r\n  { tag: 'wd-badge'},\r\n  { tag: 'wd-button' },\r\n  { tag: 'wd-calendar'},\r\n  { tag: 'wd-card'},\r\n  { tag: 'wd-cell',docSource:'cell'},\r\n  { tag: 'wd-cell-group',docSource:'cell'},\r\n  { tag: 'wd-checkbox'},\r\n  { tag: 'wd-circle'},\r\n  { tag: 'wd-col-picker'},\r\n  { tag: 'wd-collapse-item', docSource: 'collapse'},\r\n  { tag: 'wd-collapse', docSource: 'collapse'},\r\n  { tag: 'wd-config-provider'},\r\n  { tag: 'wd-count-down'},\r\n  { tag: 'wd-count-to'},\r\n  { tag: 'wd-curtain'},\r\n  { tag: 'wd-datetime-picker' },\r\n  { tag: 'wd-divider'},\r\n  { tag: 'wd-drop-menu'},\r\n  { tag: 'wd-fab'},\r\n  { tag: 'wd-floating-panel' },\r\n  { tag: 'wd-form'},\r\n  { tag: 'wd-gap'},\r\n  { tag: 'wd-grid'},\r\n  { tag: 'wd-icon'},\r\n  { tag: 'wd-img' },\r\n  { tag: 'wd-index-bar'},\r\n  { tag: 'wd-input-number', module: './wd-input-number' },\r\n  { tag: 'wd-input', module: './wd-input' },\r\n  { tag: 'wd-keyboard', module: './wd-keyboard' },\r\n  { tag: 'wd-layout', module: './wd-layout' },\r\n  { tag: 'wd-loading', module: './wd-loading' },\r\n  { tag: 'wd-loadmore', module: './wd-loadmore' },\r\n  { tag: 'wd-message-box', module: './wd-message-box' },\r\n  { tag: 'wd-navbar', module: './wd-navbar' },\r\n  { tag: 'wd-notice-bar', module: './wd-notice-bar' },\r\n  { tag: 'wd-number-keyboard', module: './wd-number-keyboard' },\r\n  { tag: 'wd-overlay', module: './wd-overlay' },\r\n  { tag: 'wd-pagination', module: './wd-pagination' },\r\n  { tag: 'wd-password-input', module: './wd-password-input' },\r\n  { tag: 'wd-picker', module: './wd-picker' },\r\n  { tag: 'wd-popover', module: './wd-popover' },\r\n  { tag: 'wd-popup', module: './wd-popup' },\r\n  { tag: 'wd-progress', module: './wd-progress' },\r\n  { tag: 'wd-radio', module: './wd-radio' },\r\n  { tag: 'wd-rate', module: './wd-rate' },\r\n  { tag: 'wd-resize', module: './wd-resize' },\r\n  { tag: 'wd-root-portal', module: './wd-root-portal' },\r\n  { tag: 'wd-search', module: './wd-search' },\r\n  { tag: 'wd-segmented', module: './wd-segmented' },\r\n  { tag: 'wd-select-picker', module: './wd-select-picker' },\r\n  { tag: 'wd-sidebar', module: './wd-sidebar' },\r\n  { tag: 'wd-signature', module: './wd-signature' },\r\n  { tag: 'wd-skeleton', module: './wd-skeleton' },\r\n  { tag: 'wd-slider', module: './wd-slider' },\r\n  { tag: 'wd-sort-button', module: './wd-sort-button' },\r\n  { tag: 'wd-status-tip', module: './wd-status-tip' },\r\n  { tag: 'wd-steps', module: './wd-steps' },\r\n  { tag: 'wd-swipe-action' },\r\n  { tag: 'wd-swiper' },\r\n  { tag: 'wd-switch'},\r\n  { tag: 'wd-tabbar'},\r\n  { tag: 'wd-table'},\r\n  { tag: 'wd-table-col', docSource: 'table'}, // 指定文档来源为 table.md\r\n  { tag: 'wd-tabs'},\r\n  { tag: 'wd-tag'},\r\n  { tag: 'wd-text' },\r\n  { tag: 'wd-textarea'},\r\n  { tag: 'wd-toast' },\r\n  { tag: 'wd-tooltip'},\r\n  { tag: 'wd-transition'},\r\n  { tag: 'wd-upload'},\r\n  { tag: 'wd-watermark'}\r\n];\r\n\r\n// 默认触发字符\r\nexport const DEFAULT_TRIGGERS = [\"<\", \" \", \":\", '\"', \"'\"];\r\n\r\n// 动态导入所有组件提供者\r\nexport async function loadComponentProviders(tag: string, modulePath: string) {\r\n  try {\r\n    const componentName = tag.replace('wd-', '');\r\n    // 查找组件配置\r\n    const componentConfig = COMPONENT_MAP.find(item => item.tag === tag);\r\n    // 传递文档来源参数\r\n    const componentMeta = loadComponentSchema(componentName, componentConfig?.docSource);\r\n    \r\n    return {\r\n      provider: new GenericComponentCompletionProvider(tag, componentMeta),\r\n      hover: new GenericComponentHoverProvider(tag, componentMeta)\r\n    };\r\n  } catch (error) {\r\n    console.error(`Failed to load component providers for ${tag}:`, error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// 根据标签名获取类名\r\nfunction getComponentClassName(tag: string): string {\r\n  // 移除 'wd-' 前缀并转换为大驼峰命名\r\n  return tag.substring(3)\r\n    .split('-')\r\n    .map(word => word.charAt(0).toUpperCase() + word.substring(1))\r\n    .join('');\r\n}","import * as vscode from 'vscode';\r\n\r\n// ======================== 工具函数 ========================\r\n// 转义正则表达式特殊字符\r\nfunction escapeRegExp(str: string) {\r\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\n\r\n// 驼峰式转短横线式\r\nfunction camelToKebab(str: string): string {\r\n  return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();\r\n}\r\n\r\n// 短横线式转驼峰式\r\nfunction kebabToCamel(str: string): string {\r\n  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());\r\n}\r\n\r\n/**\r\n * 判断光标是否在标签名上（支持驼峰和短横线式）\r\n */\r\nexport function isOnTagName(\r\n  document: vscode.TextDocument,\r\n  position: vscode.Position,\r\n  tagName: string\r\n): boolean {\r\n  const line = document.lineAt(position);\r\n  const lineText = line.text;\r\n  const cursorOffset = position.character;\r\n\r\n  // 1. 向左查找 '<'\r\n  let tagStart = -1;\r\n  for (let i = cursorOffset; i >= 0; i--) {\r\n    if (lineText[i] === '<') {\r\n      tagStart = i;\r\n      break;\r\n    }\r\n  }\r\n  if (tagStart === -1) return false;\r\n\r\n  // 2. 同时匹配驼峰和短横线式\r\n  const kebabTagName = camelToKebab(tagName);\r\n  const tagRegex = new RegExp(`^<\\\\/?(${escapeRegExp(tagName)}|${escapeRegExp(kebabTagName)})`);\r\n  \r\n  const tagPrefix = lineText.substring(tagStart);\r\n  const match = tagPrefix.match(tagRegex);\r\n  \r\n  if (!match) return false;\r\n  \r\n  // 3. 计算标签名的实际位置范围\r\n  const actualTagName = match[1];\r\n  const actualTagStart = tagStart + match[0].indexOf(actualTagName);\r\n  const actualTagEnd = actualTagStart + actualTagName.length;\r\n  \r\n  // 4. 检查光标是否在标签名范围内\r\n  return cursorOffset >= actualTagStart && cursorOffset < actualTagEnd;\r\n}\r\n\r\n/**\r\n * 获取光标所在属性名及标签名（支持驼峰和短横线式）\r\n */\r\nexport function getAttributeInfoAtPosition(\r\n  document: vscode.TextDocument,\r\n  position: vscode.Position\r\n): { attrName: string; tagName: string; isEvent: boolean; isDynamic: boolean } | null {\r\n\r\n  /* ---------- 1. 找到标签开始、结束位置（跨行） ---------- */\r\n  const startTagOpen = document.positionAt(\r\n    document.offsetAt(position) - document.offsetAt(position)   // 从 0 到光标\r\n  );\r\n  let openAngle = -1;\r\n  // 向前找最近的 <\r\n  for (let line = position.line; line >= 0; line--) {\r\n    const txt = document.lineAt(line).text;\r\n    const col = line === position.line ? position.character : txt.length - 1;\r\n    for (let i = col; i >= 0; i--) {\r\n      if (txt[i] === '<') {\r\n        openAngle = document.offsetAt(new vscode.Position(line, i));\r\n        break;\r\n      }\r\n    }\r\n    if (openAngle !== -1) break;\r\n  }\r\n  if (openAngle === -1) return null;\r\n\r\n  let closeAngle = -1;\r\n  // 向后找最近的 >\r\n  for (let line = position.line, lineCount = document.lineCount; line < lineCount; line++) {\r\n    const txt = document.lineAt(line).text;\r\n    const startCol = line === position.line ? position.character : 0;\r\n    for (let i = startCol; i < txt.length; i++) {\r\n      if (txt[i] === '>') {\r\n        closeAngle = document.offsetAt(new vscode.Position(line, i)) + 1;\r\n        break;\r\n      }\r\n    }\r\n    if (closeAngle !== -1) break;\r\n  }\r\n  if (closeAngle === -1) return null; // 没找到闭合\r\n\r\n  /* ---------- 2. 取出完整标签文本 ---------- */\r\n  const tagRange = new vscode.Range(document.positionAt(openAngle), document.positionAt(closeAngle));\r\n  const tagContent = document.getText(tagRange); // 跨行也一次性拿到\r\n\r\n  /* ---------- 3. 以下是你原来的逻辑 ---------- */\r\n  const tagNameMatch = tagContent.match(/^<([a-zA-Z0-9-]+)/);\r\n  if (!tagNameMatch) return null;\r\n  const tagName = tagNameMatch[1];\r\n\r\n  const cursorOffset = document.offsetAt(position) - openAngle; // 光标在 tagContent 里的偏移\r\n  // 改进的正则表达式，支持带值的属性\r\n  const attrRegex = /(?:v-bind:|v-on:|@|:)?([a-zA-Z0-9-_.]+)(?:=(\"[^\"]*\"|'[^']*'|[^>\\s]*))?/g;\r\n  let match;\r\n  \r\n  while ((match = attrRegex.exec(tagContent)) !== null) {\r\n    const fullMatch = match[0];\r\n    const rawAttrName = match[1];\r\n    // 使用原始属性名（保持kebab-case格式）\r\n    const attrName = rawAttrName;\r\n    const attrStart = match.index;\r\n    const attrEnd   = attrStart + fullMatch.length;\r\n    \r\n    if (cursorOffset >= attrStart && cursorOffset <= attrEnd) {\r\n      return {\r\n        attrName, // 保持原始格式用于匹配\r\n        tagName,\r\n        isEvent: fullMatch.startsWith('@') || fullMatch.startsWith('v-on:'),\r\n        isDynamic: fullMatch.startsWith(':') || fullMatch.startsWith('v-bind:'),\r\n      };\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n// ======================== 补全提供者 ========================\r\n/**\r\n * 通用组件完成项提供者基类（支持驼峰和短横线式属性）\r\n */\r\nexport abstract class ComponentCompletionProvider implements vscode.CompletionItemProvider {\r\n  protected abstract componentName: string;\r\n  protected abstract componentMeta: any;\r\n\r\n  provideCompletionItems(\r\n    document: vscode.TextDocument,\r\n    position: vscode.Position\r\n  ): vscode.ProviderResult<vscode.CompletionItem[]> {\r\n    const linePrefix = document.lineAt(position).text.substring(0, position.character);\r\n\r\n    // 1. 组件标签补全（支持驼峰和短横线式）\r\n    const kebabComponentName = camelToKebab(this.componentName);\r\n    const tagRegex = new RegExp(`<(${this.componentName.replace(/-/g, '(-)?')}|${kebabComponentName}(\\\\s+[^>]*)?)?$`);\r\n    if (linePrefix.match(tagRegex)) {\r\n      // 创建两种形式的标签补全\r\n      const items: vscode.CompletionItem[] = [];\r\n      \r\n      // 驼峰式标签\r\n      // const camelItem = new vscode.CompletionItem(\r\n      //   this.componentName,\r\n      //   vscode.CompletionItemKind.Class\r\n      // );\r\n      // camelItem.documentation = new vscode.MarkdownString(this.componentMeta.documentation);\r\n      // camelItem.insertText = this.getTagSnippet(false);\r\n      // camelItem.detail = \"wot uni 组件 - 驼峰式标签\";\r\n      // items.push(camelItem);\r\n      \r\n      // 短横线式标签\r\n      const kebabItem = new vscode.CompletionItem(\r\n        kebabComponentName,\r\n        vscode.CompletionItemKind.Class\r\n      );\r\n      kebabItem.documentation = new vscode.MarkdownString(this.componentMeta.documentation);\r\n      kebabItem.insertText = this.getTagSnippet(true);\r\n      kebabItem.detail = \"wot uni 组件\";\r\n      items.push(kebabItem);\r\n      \r\n      return items;\r\n    }\r\n\r\n    // 2. 属性补全（增强支持所有Vue写法）\r\n    const attrContextRegex = new RegExp(`<(${this.componentName}|${kebabComponentName})\\\\b[^>]*$`);\r\n    const eventContextRegex = /(@|v-on:)[a-zA-Z0-9-]*$/;\r\n    const dynamicAttrContextRegex = /(:|v-bind:)[a-zA-Z0-9-]*$/;\r\n    \r\n    if (linePrefix.match(attrContextRegex)) {\r\n      const items: vscode.CompletionItem[] = [];\r\n      \r\n      // 静态属性补全（同时提供驼峰式和短横线式）\r\n      this.componentMeta.props.forEach((prop: any) => {\r\n        // 驼峰式补全项\r\n        const camelItem = this.createPropCompletionItem(prop, false);\r\n        items.push(camelItem);\r\n        \r\n        // 短横线式补全项\r\n        const kebabItem = this.createPropCompletionItem(prop, true);\r\n        items.push(kebabItem);\r\n      });\r\n      \r\n      // 动态属性补全（同时提供两种形式）\r\n      this.componentMeta.props.forEach((prop: any) => {\r\n        // 驼峰式动态绑定\r\n        const camelDynamicItem = this.createDynamicPropItem(prop, false);\r\n        items.push(camelDynamicItem);\r\n        \r\n        // 短横线式动态绑定\r\n        const kebabDynamicItem = this.createDynamicPropItem(prop, true);\r\n        items.push(kebabDynamicItem);\r\n      });\r\n      \r\n      // 事件补全（同时提供两种形式）\r\n      this.componentMeta.events?.forEach((event: any) => {\r\n        // 驼峰式事件\r\n        const camelEventItem = this.createEventItem(event, false);\r\n        items.push(camelEventItem);\r\n        \r\n        // 短横线式事件\r\n        const kebabEventItem = this.createEventItem(event, true);\r\n        items.push(kebabEventItem);\r\n      });\r\n      \r\n      return items;\r\n    }\r\n    \r\n    // 3. 事件上下文补全（当输入@或v-on:时）\r\n    if (linePrefix.match(eventContextRegex)) {\r\n      const items: vscode.CompletionItem[] = [];\r\n      \r\n      this.componentMeta.events?.forEach((event: any) => {\r\n        // 驼峰式事件名\r\n        const camelItem = new vscode.CompletionItem(\r\n          event.name,\r\n          vscode.CompletionItemKind.Event\r\n        );\r\n        camelItem.documentation = event.description;\r\n        camelItem.insertText = new vscode.SnippetString(`${event.name}=\"\\${1:handler}\"`);\r\n        camelItem.detail = \"驼峰式事件\";\r\n        items.push(camelItem);\r\n        \r\n        // 短横线式事件名\r\n        const kebabItem = new vscode.CompletionItem(\r\n          camelToKebab(event.name),\r\n          vscode.CompletionItemKind.Event\r\n        );\r\n        kebabItem.documentation = event.description;\r\n        kebabItem.insertText = new vscode.SnippetString(`${camelToKebab(event.name)}=\"\\${1:handler}\"`);\r\n        kebabItem.detail = \"短横线式事件\";\r\n        items.push(kebabItem);\r\n      });\r\n      \r\n      return items;\r\n    }\r\n    \r\n    // 4. 动态属性上下文补全（当输入:或v-bind:时）\r\n    if (linePrefix.match(dynamicAttrContextRegex)) {\r\n      const items: vscode.CompletionItem[] = [];\r\n      \r\n      this.componentMeta.props.forEach((prop: any) => {\r\n        // 驼峰式属性名\r\n        const camelItem = new vscode.CompletionItem(\r\n          prop.name,\r\n          vscode.CompletionItemKind.Property\r\n        );\r\n        camelItem.documentation = prop.description;\r\n        camelItem.insertText = new vscode.SnippetString(`${prop.name}=\"\\${1:value}\"`);\r\n        camelItem.detail = \"驼峰式属性\";\r\n        items.push(camelItem);\r\n        \r\n        // 短横线式属性名\r\n        const kebabItem = new vscode.CompletionItem(\r\n          camelToKebab(prop.name),\r\n          vscode.CompletionItemKind.Property\r\n        );\r\n        kebabItem.documentation = prop.description;\r\n        kebabItem.insertText = new vscode.SnippetString(`${camelToKebab(prop.name)}=\"\\${1:value}\"`);\r\n        kebabItem.detail = \"短横线式属性\";\r\n        items.push(kebabItem);\r\n      });\r\n      \r\n      return items;\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  // 创建属性补全项（支持两种命名方式）\r\n  private createPropCompletionItem(prop: any, isKebabCase: boolean): vscode.CompletionItem {\r\n    const propName = isKebabCase ? camelToKebab(prop.name) : prop.name;\r\n    const item = new vscode.CompletionItem(\r\n      propName,\r\n      vscode.CompletionItemKind.Property\r\n    );\r\n    item.documentation = prop.description;\r\n    item.detail = isKebabCase ? \"短横线式属性\" : \"驼峰式属性\";\r\n    \r\n    if (prop.type === 'enum') {\r\n      item.insertText = new vscode.SnippetString(\r\n        `${propName}=\"\\${1|${prop.values!.join(',')}|}\"`\r\n      );\r\n    } else if (prop.type === 'boolean') {\r\n      // 布尔属性支持简写（仅驼峰式）\r\n      if (!isKebabCase) {\r\n        const booleanItem = new vscode.CompletionItem(\r\n          prop.name,\r\n          vscode.CompletionItemKind.Property\r\n        );\r\n        booleanItem.documentation = prop.description;\r\n        booleanItem.insertText = prop.name;\r\n        booleanItem.detail = \"驼峰式属性（简写）\";\r\n        return booleanItem;\r\n      }\r\n      item.insertText = new vscode.SnippetString(`${propName}=\"\\${1|true,false|}\"`);\r\n    } else {\r\n      item.insertText = new vscode.SnippetString(`${propName}=\"$1\"`);\r\n    }\r\n    \r\n    return item;\r\n  }\r\n\r\n  // 创建动态属性补全项\r\n  private createDynamicPropItem(prop: any, isKebabCase: boolean): vscode.CompletionItem {\r\n    const propName = isKebabCase ? camelToKebab(prop.name) : prop.name;\r\n    const prefix = ':';\r\n    \r\n    const item = new vscode.CompletionItem(\r\n      `${prefix}${propName}`,\r\n      vscode.CompletionItemKind.Property\r\n    );\r\n    \r\n    item.documentation = new vscode.MarkdownString(\r\n      `**动态绑定** (${isKebabCase ? '短横线式' : '驼峰式'})\\n\\n${prop.description}\\n\\n类型: ${prop.type}`\r\n    );\r\n    \r\n    item.insertText = new vscode.SnippetString(`${prefix}${propName}=\"\\${1:value}\"`);\r\n    item.detail = isKebabCase ? \"短横线式动态属性\" : \"驼峰式动态属性\";\r\n    \r\n    return item;\r\n  }\r\n\r\n  // 创建事件补全项\r\n  private createEventItem(event: any, isKebabCase: boolean): vscode.CompletionItem {\r\n    const eventName = isKebabCase ? camelToKebab(event.name) : event.name;\r\n    const prefix = '@';\r\n    \r\n    const item = new vscode.CompletionItem(\r\n      `${prefix}${eventName}`,\r\n      vscode.CompletionItemKind.Event\r\n    );\r\n    \r\n    item.documentation = new vscode.MarkdownString(\r\n      `**事件** (${isKebabCase ? '短横线式' : '驼峰式'})\\n\\n${event.description}`\r\n    );\r\n    \r\n    item.insertText = new vscode.SnippetString(`${prefix}${eventName}=\"\\${1:handler}\"`);\r\n    item.detail = isKebabCase ? \"短横线式事件\" : \"驼峰式事件\";\r\n    \r\n    return item;\r\n  }\r\n\r\n  protected abstract getTagSnippet(isKebabCase: boolean): vscode.SnippetString;\r\n}\r\n\r\n// ======================== 悬停提供者 ========================\r\n/**\r\n * 通用组件悬停提供者基类（支持驼峰和短横线式属性）\r\n */\r\nexport abstract class ComponentHoverProvider implements vscode.HoverProvider {\r\n  protected abstract componentMeta: any;\r\n  protected abstract componentName: string;\r\n\r\n  provideHover(\r\n    document: vscode.TextDocument,\r\n    position: vscode.Position\r\n  ): vscode.ProviderResult<vscode.Hover> {\r\n    try {\r\n      \r\n      // 1. 检查是否在标签名上（支持驼峰和短横线式）\r\n      const kebabComponentName = camelToKebab(this.componentName);\r\n      if (isOnTagName(document, position, this.componentName) || \r\n          isOnTagName(document, position, kebabComponentName)) {\r\n        const markdown = new vscode.MarkdownString();\r\n        markdown.isTrusted = true;\r\n        markdown.supportHtml = true;\r\n        markdown.appendMarkdown(this.componentMeta.documentation);\r\n        return new vscode.Hover(markdown);\r\n      }\r\n\r\n      // 2. 检查是否在属性上（支持所有Vue写法）\r\n      const attrInfo = getAttributeInfoAtPosition(document, position);\r\n      \r\n      // 修复组件名称匹配逻辑\r\n      if (attrInfo && (attrInfo.tagName === this.componentName.replace('wd-', '') || \r\n                      attrInfo.tagName === kebabComponentName || \r\n                      attrInfo.tagName === kebabComponentName.replace('wd-', ''))) {\r\n        \r\n        // 处理通用属性\r\n        if (attrInfo.attrName === 'customClass') {\r\n          const markdown = new vscode.MarkdownString();\r\n          markdown.isTrusted = true;\r\n          markdown.supportHtml = true;\r\n          markdown.appendMarkdown('### 外部样式类\\n\\n');\r\n          markdown.appendMarkdown('`custom-class` 自定义样式类名，用于覆盖组件默认样式\\n\\n');\r\n          markdown.appendMarkdown('**类型**: string\\n\\n');\r\n          return new vscode.Hover(markdown);\r\n        }\r\n        \r\n        if (attrInfo.attrName === 'customStyle') {\r\n          const markdown = new vscode.MarkdownString();\r\n          markdown.isTrusted = true;\r\n          markdown.supportHtml = true;\r\n          markdown.appendMarkdown('### 外部样式类\\n\\n');\r\n          markdown.appendMarkdown('`custom-style` 自定义样式，用于覆盖组件默认样式\\n\\n');\r\n          markdown.appendMarkdown('**类型**: string\\n\\n');\r\n          return new vscode.Hover(markdown);\r\n        }\r\n\r\n        let prop, event;\r\n        \r\n        // 同时匹配驼峰式和短横线式\r\n        const findProp = (name: string) => \r\n          this.componentMeta.props.find((p: any) => \r\n            p.name === name || camelToKebab(p.name) === name || kebabToCamel(p.name) === name\r\n          );\r\n        \r\n        const findEvent = (name: string) => \r\n          this.componentMeta.events?.find((e: any) => \r\n            e.name === name || camelToKebab(e.name) === name || kebabToCamel(e.name) === name\r\n          );\r\n          \r\n        if (attrInfo.isEvent) {\r\n          event = findEvent(attrInfo.attrName);\r\n          if (!event) {\r\n            // 尝试短横线式匹配\r\n            const kebabName = camelToKebab(attrInfo.attrName);\r\n            event = findEvent(kebabName);\r\n          }\r\n          \r\n          if (!event) {\r\n            // 尝试驼峰式匹配\r\n            const camelName = kebabToCamel(attrInfo.attrName);\r\n            event = findEvent(camelName);\r\n          }\r\n          \r\n          if (event) {\r\n            const markdown = new vscode.MarkdownString();\r\n            markdown.isTrusted = true;\r\n            markdown.supportHtml = true;\r\n            \r\n            markdown.appendMarkdown(`### ${attrInfo.isDynamic ? '动态事件' : '事件'} \\`${event.name}\\`\\n\\n`);\r\n            markdown.appendMarkdown(`${event.description}\\n\\n`);\r\n            markdown.appendMarkdown(`**类型**: 事件处理器\\n\\n`);\r\n            \r\n            if (event.arguments) {\r\n              markdown.appendMarkdown(`**事件参数**: \\n`);\r\n              event.arguments.forEach((arg: any) => {\r\n                markdown.appendMarkdown(`- \\`${arg.name}\\`: ${arg.type} - ${arg.description}\\n`);\r\n              });\r\n              markdown.appendMarkdown('\\n');\r\n            }\r\n            \r\n            return new vscode.Hover(markdown);\r\n          }\r\n        } else {\r\n          // 属性悬停\r\n          prop = findProp(attrInfo.attrName);\r\n          \r\n          if (!prop) {\r\n            // 尝试短横线式匹配\r\n            const kebabName = camelToKebab(attrInfo.attrName);\r\n            prop = findProp(kebabName);\r\n          }\r\n          \r\n          if (!prop) {\r\n            // 尝试驼峰式匹配\r\n            const camelName = kebabToCamel(attrInfo.attrName);\r\n            prop = findProp(camelName);\r\n          }\r\n          \r\n          if (prop) {\r\n            const markdown = new vscode.MarkdownString();\r\n            markdown.isTrusted = true;\r\n            markdown.supportHtml = true;\r\n            \r\n            markdown.appendMarkdown(`### ${attrInfo.isDynamic ? '动态属性' : '属性'} \\`${prop.name}\\`\\n\\n`);\r\n            markdown.appendMarkdown(`${prop.description}\\n\\n`);\r\n            markdown.appendMarkdown(`**类型**: ${prop.type}\\n\\n`);\r\n            \r\n            if (prop.values) {\r\n              markdown.appendMarkdown(`**可选值**: ${prop.values.join(', ')}\\n\\n`);\r\n            }\r\n            \r\n            if (prop.default) {\r\n              markdown.appendMarkdown(`**默认值**: ${prop.default}\\n\\n`);\r\n            }\r\n            \r\n            return new vscode.Hover(markdown);\r\n          }\r\n        }\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error in provideHover:', error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\n// ======================== 诊断提供者 ========================\r\n/**\r\n * 通用组件诊断提供者基类（支持驼峰和短横线式属性）\r\n */\r\nexport abstract class ComponentDiagnosticProvider {\r\n  protected abstract componentName: string;\r\n  protected abstract componentMeta: any;\r\n  protected diagnosticCollection!: vscode.DiagnosticCollection;\r\n\r\n  constructor() {\r\n    vscode.workspace.onDidChangeTextDocument(e => this.updateDiagnostics(e.document));\r\n  }\r\n\r\n  protected initialize() {\r\n    if (!this.diagnosticCollection) {\r\n      this.diagnosticCollection = vscode.languages.createDiagnosticCollection(this.componentName);\r\n    }\r\n  }\r\n\r\n  public updateDiagnostics(document: vscode.TextDocument) {\r\n    if (document.languageId !== 'html' && document.languageId !== 'vue') return;\r\n\r\n    this.initialize();\r\n\r\n    const diagnostics: vscode.Diagnostic[] = [];\r\n    const text = document.getText();\r\n    const regex = this.getTagRegex();\r\n    let match;\r\n\r\n    while ((match = regex.exec(text))) {\r\n      const startPos = document.positionAt(match.index);\r\n      const endPos = document.positionAt(match.index + match[0].length);\r\n      const range = new vscode.Range(startPos, endPos);\r\n\r\n      this.checkAttributeValues(match[0], range, diagnostics);\r\n      this.checkDuplicateAttributes(match[0], range, diagnostics);\r\n      this.checkEventHandlers(match[0], range, diagnostics);\r\n      this.checkBooleanAttributes(match[0], range, diagnostics);\r\n      \r\n      // 调用额外的诊断方法\r\n      if (this.getAdditionalDiagnostics) {\r\n        this.getAdditionalDiagnostics(match[0], range, diagnostics);\r\n      }\r\n    }\r\n\r\n    this.diagnosticCollection.set(document.uri, diagnostics);\r\n  }\r\n\r\n  protected getTagRegex(): RegExp {\r\n    const kebabComponentName = camelToKebab(this.componentName);\r\n    return new RegExp(`<(${this.componentName}|${kebabComponentName})\\\\s+[^>]*>`, 'g');\r\n  }\r\n\r\n  protected checkAttributeValues(tag: string, range: vscode.Range, diagnostics: vscode.Diagnostic[]) {\r\n    this.componentMeta.props\r\n      .filter((prop: any) => prop.type === 'enum')\r\n      .forEach((prop: any) => {\r\n        // 同时检查驼峰式和短横线式\r\n        const propNames = [prop.name, camelToKebab(prop.name)];\r\n        \r\n        propNames.forEach(propName => {\r\n          // 检查静态属性\r\n          const staticAttrMatch = tag.match(new RegExp(`${propName}=[\"']([^\"']+)[\"']`));\r\n          if (staticAttrMatch && !prop.values.includes(staticAttrMatch[1])) {\r\n            diagnostics.push({\r\n              severity: vscode.DiagnosticSeverity.Error,\r\n              range: range,\r\n              message: `无效的 ${propName} 属性值: ${staticAttrMatch[1]}`,\r\n              source: 'wot-uni-helper'\r\n            });\r\n          }\r\n          \r\n          // 检查动态属性值（需要静态值的情况）\r\n          const dynamicAttrMatch = tag.match(new RegExp(`:${propName}=[\"']([^\"']+)[\"']`));\r\n          if (dynamicAttrMatch && !prop.values.includes(dynamicAttrMatch[1])) {\r\n            diagnostics.push({\r\n              severity: vscode.DiagnosticSeverity.Warning,\r\n              range: range,\r\n              message: `动态属性 :${propName} 使用了静态值，建议使用变量`,\r\n              source: 'wot-uni-helper'\r\n            });\r\n          }\r\n        });\r\n      });\r\n  }\r\n\r\n  protected checkDuplicateAttributes(tag: string, range: vscode.Range, diagnostics: vscode.Diagnostic[]) {\r\n    const attrs = tag.match(/(?:v-bind:|v-on:|@|:)?([a-zA-Z0-9-_.]+)=?/g) || [];\r\n    const attrMap = new Map<string, string>();\r\n    \r\n    attrs.forEach(attr => {\r\n      const match = attr.match(/(?:v-bind:|v-on:|@|:)?([a-zA-Z0-9-_.]+)/);\r\n      if (!match) return;\r\n      \r\n      const rawName = match[1];\r\n      // 标准化属性名（统一转为驼峰式）\r\n      const normalizedName = kebabToCamel(rawName);\r\n      \r\n      if (attrMap.has(normalizedName)) {\r\n        const originalRawName = attrMap.get(normalizedName);\r\n        diagnostics.push({\r\n          severity: vscode.DiagnosticSeverity.Warning,\r\n          range: range,\r\n          message: `重复的属性: ${originalRawName} 和 ${rawName} 都映射到 ${normalizedName}`,\r\n          source: 'wot-uni-helper'\r\n        });\r\n      } else {\r\n        attrMap.set(normalizedName, rawName);\r\n      }\r\n    });\r\n  }\r\n\r\n  protected checkEventHandlers(tag: string, range: vscode.Range, diagnostics: vscode.Diagnostic[]) {\r\n    this.componentMeta.events?.forEach((event: any) => {\r\n      // 同时检查驼峰式和短横线式\r\n      const eventNames = [event.name, camelToKebab(event.name)];\r\n      \r\n      eventNames.forEach(eventName => {\r\n        const eventRegex = new RegExp(`(@|v-on:)${eventName}=[\"']([^\"']*)[\"']`);\r\n        const match = tag.match(eventRegex);\r\n        \r\n        if (match) {\r\n          const handler = match[2];\r\n          // 简单检查处理器是否有效\r\n          if (!handler.trim()) {\r\n            diagnostics.push({\r\n              severity: vscode.DiagnosticSeverity.Error,\r\n              range: range,\r\n              message: `事件 ${eventName} 缺少处理器`,\r\n              source: 'wot-uni-helper'\r\n            });\r\n          } else if (!handler.includes('(') && !handler.includes(')') && !handler.startsWith('$event')) {\r\n            diagnostics.push({\r\n              severity: vscode.DiagnosticSeverity.Warning,\r\n              range: range,\r\n              message: `事件处理器应包含括号: ${handler}()`,\r\n              source: 'wot-uni-helper'\r\n            });\r\n          }\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  protected checkBooleanAttributes(tag: string, range: vscode.Range, diagnostics: vscode.Diagnostic[]) {\r\n    this.componentMeta.props\r\n      .filter((prop: any) => prop.type === 'boolean')\r\n      .forEach((prop: any) => {\r\n        // 同时检查驼峰式和短横线式\r\n        const propNames = [prop.name, camelToKebab(prop.name)];\r\n        \r\n        propNames.forEach(propName => {\r\n          // 检查静态布尔属性是否有值\r\n          const staticAttrMatch = tag.match(new RegExp(`${propName}=[\"']([^\"']*)[\"']`));\r\n          if (staticAttrMatch) {\r\n            const value = staticAttrMatch[1];\r\n            if (value && value !== 'true' && value !== 'false') {\r\n              diagnostics.push({\r\n                severity: vscode.DiagnosticSeverity.Warning,\r\n                range: range,\r\n                message: `布尔属性 ${propName} 应使用简写或动态绑定`,\r\n                source: 'wot-uni-helper'\r\n              });\r\n            }\r\n          }\r\n        });\r\n      });\r\n  }\r\n\r\n  protected abstract getAdditionalDiagnostics?(tag: string, range: vscode.Range, diagnostics: vscode.Diagnostic[]): void;\r\n}","module.exports = require(\"vscode\");","import { parseComponentMarkdown, loadComponentDoc } from './markdown-parser';\n\nexport interface ComponentMeta {\n  name: string;\n  props: Array<{\n    name: string;\n    type: 'enum' | 'boolean' | 'string' | 'number';\n    values?: string[];\n    description: string;\n    default?: string;\n    version?: string;\n  }>;\n  events: Array<{ \n    name: string; \n    description: string;\n    version?: string;\n  }>;\n  slots?: Array<{ \n    name: string; \n    description: string;\n    version?: string;\n  }>;\n  externalClasses?: Array<{ \n    name: string; \n    description: string;\n    version?: string;\n  }>;\n  dataStructures?: Array<{\n    name: string;\n    fields: Array<{\n      name: string;\n      type: string;\n      description: string;\n      version?: string;\n    }>;\n  }>;\n  documentation: string;\n}\n\n/**\n * 通用组件schema加载器\n * @param componentName 组件名称（不包含wd-前缀）\n * @param docSource 文档来源组件名称（可选）\n * @returns 组件元数据\n */\nexport function loadComponentSchema(componentName: string, docSource?: string): ComponentMeta {\n  try {\n    // 解析组件文档，传递文档来源参数\n    const componentInfo = parseComponentMarkdown(componentName, docSource);\n    // 如果解析成功，则使用解析结果；否则使用默认值\n    if (componentInfo) {\n      return {\n        name: componentInfo.name,\n        props: componentInfo.props.map(prop => ({\n          name: prop.name,\n          type: prop.type as 'enum' | 'boolean' | 'string' | 'number',\n          values: prop.values,\n          description: prop.description,\n          default: prop.default,\n          version: prop.version\n        })),\n        events: componentInfo.events.map(event => ({\n          name: event.name,\n          description: event.description,\n          version: event.version\n        })),\n        slots: componentInfo.slots?.map(slot => ({\n          name: slot.name,\n          description: slot.description,\n          version: slot.version\n        })),\n        externalClasses: componentInfo.externalClasses?.map(externalClass => ({\n          name: externalClass.name,\n          description: externalClass.description,\n          version: externalClass.version\n        })),\n        dataStructures: componentInfo.dataStructures?.map(structure => ({\n          name: structure.name,\n          fields: structure.fields.map(field => ({\n            name: field.name,\n            type: field.type,\n            description: field.description,\n            version: field.version\n          }))\n        })),\n        documentation: componentInfo.documentation\n      };\n    }\n    \n    // 默认值\n    return {\n      name: `wd-${componentName}`,\n      props: [],\n      events: [],\n      documentation: loadComponentDoc(componentName, docSource) // 传递文档来源参数\n    };\n  } catch (error) {\n    console.error(`加载组件schema失败: ${componentName}`, error);\n    return {\n      name: `wd-${componentName}`,\n      props: [],\n      events: [],\n      documentation: ''\n    };\n  }\n}\n\n/**\n * 异步加载组件schema\n * @param componentName 组件名称（不包含wd-前缀）\n * @param docSource 文档来源组件名称（可选）\n * @returns 组件元数据的Promise\n */\nexport async function loadComponentSchemaAsync(componentName: string, docSource?: string): Promise<ComponentMeta> {\n  return loadComponentSchema(componentName, docSource);\n}","// 静态导入所有组件\r\n\r\nimport * as vscode from \"vscode\";\r\nimport { COMPONENT_MAP, DEFAULT_TRIGGERS } from '../utils/component_map';\r\nimport { loadComponentSchema } from '../utils/schema-loader';\r\nimport { GenericComponentCompletionProvider, GenericComponentHoverProvider } from '../providers/component-factory';\r\n\r\ninterface ComponentEntry {\r\n  tag: string;\r\n  provider: vscode.CompletionItemProvider;\r\n  hover: vscode.HoverProvider;\r\n  triggers: string[];\r\n}\r\n\r\nexport async function registerAll(context: vscode.ExtensionContext) {\r\n  console.log(`Registering ${COMPONENT_MAP.length} components`);\r\n  \r\n  // 动态注册所有组件\r\n  for (const { tag,docSource } of COMPONENT_MAP) {\r\n    try {\r\n      // 修复模块路径计算\r\n      const componentName = tag.replace('wd-', '');\r\n      \r\n      // 使用通用组件提供者\r\n      const componentMeta = loadComponentSchema(componentName,docSource);\r\n      const provider = new GenericComponentCompletionProvider(tag, componentMeta);\r\n      const hover = new GenericComponentHoverProvider(tag, componentMeta);\r\n      // 修复选择器，使其正确匹配组件标签\r\n      const selector: vscode.DocumentSelector = [\r\n        { language: \"vue\", scheme: \"file\" },\r\n        { language: \"html\", scheme: \"file\" }\r\n      ];\r\n      \r\n      context.subscriptions.push(\r\n        vscode.languages.registerCompletionItemProvider(\r\n          selector,\r\n          provider,\r\n          ...DEFAULT_TRIGGERS\r\n        )\r\n      );\r\n      \r\n      context.subscriptions.push(\r\n        vscode.languages.registerHoverProvider(selector, hover)\r\n      );\r\n      \r\n      console.log(`Successfully registered ${tag}`);\r\n    } catch (error) {\r\n      console.error(`Failed to register ${tag}:`, error);\r\n    }\r\n  }\r\n  \r\n  console.log(`Finished registering components`);\r\n}","module.exports = require(\"fs\");","import * as fs from \"fs\";\nimport * as path from \"path\";\n\ninterface ComponentInfo {\n  name: string;\n  props: Array<{\n    name: string;\n    type: string;\n    values?: string[];\n    description: string;\n    default?: string;\n    version?: string;\n  }>;\n  events: Array<{\n    name: string;\n    description: string;\n    version?: string;\n  }>;\n  slots?: Array<{\n    name: string;\n    description: string;\n    version?: string;\n  }>;\n  externalClasses?: Array<{\n    name: string;\n    description: string;\n    version?: string;\n  }>;\n  dataStructures?: Array<{\n    name: string;\n    fields: Array<{\n      name: string;\n      type: string;\n      description: string;\n      version?: string;\n    }>;\n  }>;\n  documentation: string;\n}\n\n/**\n * 解析 Markdown 文档并提取组件信息\n * @param componentName 组件名称（不包含wd-前缀）\n * @param docSource 文档来源组件名称（可选）\n * @returns 组件信息对象\n */\nexport function parseComponentMarkdown(\n  componentName: string,\n  docSource?: string\n): ComponentInfo | null {\n  try {\n    // 如果指定了文档来源，则使用来源文档\n    const actualComponentName = docSource || componentName;\n\n    // 尝试多种路径查找文档文件\n    const possiblePaths = [\n      // path.resolve(__dirname, `../src/component/${actualComponentName}.md`), // 开发环境\n      path.resolve(__dirname, `../../src/component/${actualComponentName}.md`), // 打包后运行环境\n    ];\n\n    let docPath = \"\";\n    for (const possiblePath of possiblePaths) {\n      if (fs.existsSync(possiblePath)) {\n        docPath = possiblePath;\n        break;\n      }\n    }\n\n    if (!docPath) {\n      console.warn(`文档文件不存在，尝试路径: ${possiblePaths.join(\", \")}`);\n      return null;\n    }\n\n    // 读取文档内容\n    const content = fs.readFileSync(docPath, \"utf-8\");\n\n    // 如果是子组件且指定了文档来源，需要特殊处理\n    if (docSource) {\n      // 通用处理子组件情况，如 wd-table-col 从 table.md 中提取 TableColumn 相关信息\n      // 将组件名从 kebab-case 转换为 PascalCase 用于匹配标题\n      // 提取子组件 Attributes 表格\n      const props = extractTableSection(content, \"Attributes\", componentName);\n      // 提取子组件 Slot 表格（如果存在）\n      const slots = extractTableSection(content, \"Slot\", componentName).concat(\n        extractTableSection(content, \"Slots\", componentName)\n      );\n      // 提取子组件 Events 表格（如果存在）\n      const events = extractTableSection(content, \"Events\", componentName);\n      // 提取子组件外部样式类表格（如果存在）\n      const externalClasses = extractTableSection(\n        content,\n        \"外部样式类\",\n        componentName\n      );\n      // 提取自定义数据结构表格（如 Action 数据结构、Panel 数据结构等）\n      const dataStructures = extractDataStructures(content);\n      // 返回子组件信息对象\n      return {\n        name: `wd-${componentName}`,\n        props: props.map((prop) => {\n          // 解析属性类型\n          let type: string = prop[2]?.toLowerCase() || \"string\";\n          let values: string[] | undefined;\n\n          // 如果类型是枚举类型，解析可选值\n          if (\n            type === \"string\" &&\n            prop[3] &&\n            prop[3] !== \"-\" &&\n            prop[3].includes(\"/\")\n          ) {\n            values = prop[3]\n              .split(\"/\")\n              .map((v) => v.trim())\n              .filter((v) => v !== \"-\");\n            if (values.length > 0) {\n              type = \"enum\";\n            }\n          }\n\n          // 特殊处理scope属性，它有明确的类型ButtonScope\n          if (prop[0] === \"scope\") {\n            type = \"enum\";\n            values = [\"phoneNumber\", \"userInfo\"];\n          }\n\n          return {\n            name: prop[0],\n            type,\n            values,\n            description: prop[1] || \"\",\n            default: prop[4] && prop[4] !== \"-\" ? prop[4] : undefined,\n            version: prop[5] && prop[5] !== \"-\" ? prop[5] : undefined,\n          };\n        }),\n        events: events.map((event) => ({\n          name: event[0],\n          description: event[1] || \"\",\n          version: event[3] && event[3] !== \"-\" ? event[3] : undefined,\n        })),\n        slots:\n          slots.length > 0\n            ? slots.map((slot) => ({\n                name: slot[0],\n                description: slot[1] || \"\",\n                version: slot[2] && slot[2] !== \"-\" ? slot[2] : undefined,\n              }))\n            : undefined,\n        externalClasses:\n          externalClasses.length > 0\n            ? externalClasses.map((externalClass) => ({\n                name: externalClass[0],\n                description: externalClass[1] || \"\",\n                version:\n                  externalClass[2] && externalClass[2] !== \"-\"\n                    ? externalClass[2]\n                    : undefined,\n              }))\n            : undefined,\n        dataStructures: dataStructures.length > 0 ? dataStructures : undefined,\n        documentation: content,\n      };\n    }\n\n    // 提取 Attributes 表格\n    const props = extractTableSection(content, \"Attributes\");\n    // 提取 Events 表格\n    const events = extractTableSection(content, \"Events\");\n    // 提取 Slots 表格（如果存在）\n    const slots = extractTableSection(content, \"Slot\").concat(\n      extractTableSection(content, \"Slots\")\n    );\n    // 提取外部样式类表格（如果存在）\n    const externalClasses = extractTableSection(content, \"外部样式类\");\n    // 提取自定义数据结构表格（如 Action 数据结构、Panel 数据结构等）\n    const dataStructures = extractDataStructures(content);\n    // 返回组件信息对象\n    return {\n      name: `wd-${componentName}`,\n      props: props.map((prop) => {\n        // 解析属性类型\n        let type: string = prop[2]?.toLowerCase() || \"string\";\n        let values: string[] | undefined;\n\n        // 如果类型是枚举类型，解析可选值\n        if (\n          type === \"string\" &&\n          prop[3] &&\n          prop[3] !== \"-\" &&\n          prop[3].includes(\"/\")\n        ) {\n          values = prop[3]\n            .split(\"/\")\n            .map((v) => v.trim())\n            .filter((v) => v !== \"-\");\n          if (values.length > 0) {\n            type = \"enum\";\n          }\n        }\n\n        // 特殊处理scope属性，它有明确的类型ButtonScope\n        if (prop[0] === \"scope\") {\n          type = \"enum\";\n          values = [\"phoneNumber\", \"userInfo\"];\n        }\n\n        return {\n          name: prop[0],\n          type,\n          values,\n          description: prop[1] || \"\",\n          default: prop[4] && prop[4] !== \"-\" ? prop[4] : undefined,\n          version: prop[5] && prop[5] !== \"-\" ? prop[5] : undefined,\n        };\n      }),\n      events: events.map((event) => ({\n        name: event[0],\n        description: event[1] || \"\",\n        version: event[3] && event[3] !== \"-\" ? event[3] : undefined,\n      })),\n      slots:\n        slots.length > 0\n          ? slots.map((slot) => ({\n              name: slot[0],\n              description: slot[1] || \"\",\n              version: slot[2] && slot[2] !== \"-\" ? slot[2] : undefined,\n            }))\n          : undefined,\n      externalClasses:\n        externalClasses.length > 0\n          ? externalClasses.map((externalClass) => ({\n              name: externalClass[0],\n              description: externalClass[1] || \"\",\n              version:\n                externalClass[2] && externalClass[2] !== \"-\"\n                  ? externalClass[2]\n                  : undefined,\n            }))\n          : undefined,\n      dataStructures: dataStructures.length > 0 ? dataStructures : undefined,\n      documentation: content,\n    };\n  } catch (error) {\n    console.error(`解析文档文件失败: ${componentName}`, error);\n    return null;\n  }\n}\n\n/**\n * 从 Markdown 内容中提取指定标题下的表格内容\n * @param content       Markdown 全文\n * @param sectionTitle  段落标题，如 \"Attributes\"\n * @param componentName 组件短横线名，如 \"cell\"\n * @returns             表格数据数组\n */\nfunction extractTableSection(\n  content: string,\n  sectionTitle: string,\n  componentName?: string\n): string[][] {\n  const escape = (s: string) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n  /* 公用：从第一个 '|' 到 '\\n\\n'，再去掉表头 */\n  const sliceTable = (src: string, from: number): string[][] => {\n    const end = src.indexOf('\\n\\n', from);\n    const raw = src.substring(from, end === -1 ? src.length : end);\n    const lines = raw.split('\\n').filter(l => l.trim() && l.includes('|'));\n    if (lines.length < 3) return [];\n    return lines.slice(2).map(line =>\n      line.split('|')\n          .map(cell => cell.trim())\n          .filter((_, i, arr) => i > 0 && i < arr.length - 1)\n    ).filter(row => row.length > 0);\n  };\n\n  /* ===== 1. 精确匹配：整行等于 \"## PascalCase Attributes\" ===== */\n  if (componentName) {\n    const pascal = componentName\n      .split('-')\n      .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n      .join('');\n    const exactReg = new RegExp(\n      `(?:^|\\\\n)#{2,3}\\\\s*${pascal}\\\\s+${escape(sectionTitle)}\\\\s*$`,\n      'im'\n    );\n    const m = exactReg.exec(content);\n    if (m) {\n      const pipe = content.indexOf('|', m.index + m[0].length);\n      if (pipe !== -1) return sliceTable(content, pipe);\n    }\n  }\n\n  /* ===== 2. 模糊匹配：行内包含组件名+标题 ===== */\n  if (componentName) {\n    const pascal = componentName\n      .split('-')\n      .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n      .join('');\n    const fuzzyReg = new RegExp(\n      `(?:^|\\\\n)#{2,3}\\\\s*\\\\w*${pascal}\\\\w*\\\\s+${escape(sectionTitle)}\\\\s*$`,\n      'im'\n    );\n    const m = fuzzyReg.exec(content);\n    if (m) {\n      const pipe = content.indexOf('|', m.index + m[0].length);\n      if (pipe !== -1) return sliceTable(content, pipe);\n    }\n  }\n\n  /* ===== 3. 通用回落：纯 \"## Attributes\" ===== */\n  const normalReg = new RegExp(\n    `(?:^|\\\\n)#{2,3}\\\\s*${escape(sectionTitle)}\\\\s*$`,\n    'im'\n  );\n  const m = normalReg.exec(content);\n  if (m) {\n    const pipe = content.indexOf('|', m.index + m[0].length);\n    if (pipe !== -1) return sliceTable(content, pipe);\n  }\n\n  return [];\n}\n\n/**\n * 提取自定义数据结构信息\n * @param content Markdown 内容\n * @returns 数据结构数组\n */\nfunction extractDataStructures(content: string): Array<{\n  name: string;\n  fields: Array<{\n    name: string;\n    type: string;\n    description: string;\n    version?: string;\n  }>;\n}> {\n  const dataStructures: Array<{\n    name: string;\n    fields: Array<{\n      name: string;\n      type: string;\n      description: string;\n      version?: string;\n    }>;\n  }> = [];\n\n  // 查找所有 \"xxx 数据结构\" 标题\n  const dataStructureRegex =\n    /\\n## (.*?数据结构)\\n\\n([\\s\\S]*?)(?=\\n## |\\n### |\\n\\[|\\Z)/g;\n  let match;\n\n  while ((match = dataStructureRegex.exec(content)) !== null) {\n    const structureName = match[1].trim();\n    const tableContent = match[2];\n\n    // 解析数据结构表格\n    const lines = tableContent.split(\"\\n\").filter((line) => line.trim() !== \"\");\n    if (lines.length >= 3) {\n      // 移除表头分隔行\n      const dataLines = lines.slice(2);\n\n      // 解析每行数据\n      const fields = dataLines\n        .map((line) => {\n          const cells = line\n            .split(\"|\")\n            .map((cell) => cell.trim())\n            .filter((cell) => cell);\n          if (cells.length >= 3) {\n            return {\n              name: cells[0],\n              type: cells[2],\n              description: cells[1] || \"\",\n              version: cells[3] && cells[3] !== \"-\" ? cells[3] : undefined,\n            };\n          }\n          return null;\n        })\n        .filter((field) => field !== null) as Array<{\n        name: string;\n        type: string;\n        description: string;\n        version?: string;\n      }>;\n\n      dataStructures.push({\n        name: structureName,\n        fields,\n      });\n    }\n  }\n\n  return dataStructures;\n}\n\n/**\n * 同步读取组件文档内容\n * @param componentName 组件名称（不包含wd-前缀）\n * @param docSource 文档来源组件名称（可选）\n * @returns 组件文档内容\n */\nexport function loadComponentDoc(\n  componentName: string,\n  docSource?: string\n): string {\n  try {\n    // 如果指定了文档来源，则使用来源文档\n    const actualComponentName = docSource || componentName;\n\n    // 尝试多种路径查找文档文件\n    const possiblePaths = [\n      // path.resolve(__dirname, `../src/component/${actualComponentName}.md`), // 开发环境\n      path.resolve(__dirname, `../../src/component/${actualComponentName}.md`), // 打包后运行环境\n    ];\n\n    let docPath = \"\";\n    for (const possiblePath of possiblePaths) {\n      if (fs.existsSync(possiblePath)) {\n        docPath = possiblePath;\n        break;\n      }\n    }\n\n    if (!docPath) {\n      console.warn(`文档文件不存在，尝试路径: ${possiblePaths.join(\", \")}`);\n      return \"\";\n    }\n\n    // 读取文档内容\n    const content = fs.readFileSync(docPath, \"utf-8\");\n    console.log(`加载文档: ${componentName}`);\n    return content;\n  } catch (error) {\n    console.error(`读取文档文件失败: ${componentName}`, error);\n    return \"\";\n  }\n}\n\n/**\n * 异步读取组件文档内容\n * @param componentName 组件名称（不包含wd-前缀）\n * @param docSource 文档来源组件名称（可选）\n * @returns 组件文档内容\n */\nexport async function loadComponentDocAsync(\n  componentName: string,\n  docSource?: string\n): Promise<string> {\n  try {\n    // 如果指定了文档来源，则使用来源文档\n    const actualComponentName = docSource || componentName;\n\n    // 尝试多种路径查找文档文件\n    const possiblePaths = [\n      path.resolve(__dirname, `../src/component/${actualComponentName}.md`), // 开发环境\n      // path.resolve(__dirname, `../../src/component/${actualComponentName}.md`), // 打包后运行环境\n    ];\n\n    let docPath = \"\";\n    for (const possiblePath of possiblePaths) {\n      if (fs.existsSync(possiblePath)) {\n        docPath = possiblePath;\n        break;\n      }\n    }\n\n    if (!docPath) {\n      console.warn(`文档文件不存在，尝试路径: ${possiblePaths.join(\", \")}`);\n      return \"\";\n    }\n\n    // 使用 Promise 方式读取文件\n    const content = await fs.promises.readFile(docPath, \"utf-8\");\n    return content;\n  } catch (error) {\n    console.error(`读取文档文件失败: ${componentName}`, error);\n    return \"\";\n  }\n}\n","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import * as vscode from 'vscode';\nimport { registerAll } from './providers/index';\n\nexport function activate(context: vscode.ExtensionContext) {\n  console.log('Wot Uni Helper 已激活');\n  registerAll(context);\n}\n\nexport function deactivate() {}"],"names":["GenericComponentCompletionProvider","ComponentCompletionProvider","componentName","componentMeta","constructor","super","this","getTagSnippet","isKebab","tagName","replace","g","toUpperCase","vscode","SnippetString","GenericComponentHoverProvider","ComponentHoverProvider","GenericComponentDiagnosticProvider","ComponentDiagnosticProvider","getAdditionalDiagnostics","tag","range","diagnostics","async","modulePath","componentConfig","COMPONENT_MAP","find","item","loadComponentSchema","docSource","provider","hover","error","console","module","DEFAULT_TRIGGERS","escapeRegExp","str","camelToKebab","toLowerCase","kebabToCamel","isOnTagName","document","position","lineText","lineAt","text","cursorOffset","character","tagStart","i","kebabTagName","tagRegex","RegExp","match","substring","actualTagName","actualTagStart","indexOf","actualTagEnd","length","getAttributeInfoAtPosition","positionAt","offsetAt","openAngle","line","txt","Position","closeAngle","lineCount","tagRange","Range","tagContent","getText","tagNameMatch","attrRegex","exec","fullMatch","attrName","attrStart","index","attrEnd","isEvent","startsWith","isDynamic","provideCompletionItems","linePrefix","kebabComponentName","items","kebabItem","CompletionItem","CompletionItemKind","Class","documentation","MarkdownString","insertText","detail","push","attrContextRegex","props","forEach","prop","camelItem","createPropCompletionItem","camelDynamicItem","createDynamicPropItem","kebabDynamicItem","events","event","camelEventItem","createEventItem","kebabEventItem","name","Event","description","Property","isKebabCase","propName","type","values","join","booleanItem","eventName","provideHover","markdown","isTrusted","supportHtml","appendMarkdown","Hover","attrInfo","findProp","p","findEvent","e","arguments","arg","default","diagnosticCollection","workspace","onDidChangeTextDocument","updateDiagnostics","initialize","languages","createDiagnosticCollection","languageId","regex","getTagRegex","startPos","endPos","checkAttributeValues","checkDuplicateAttributes","checkEventHandlers","checkBooleanAttributes","set","uri","filter","staticAttrMatch","includes","severity","DiagnosticSeverity","Error","message","source","dynamicAttrMatch","Warning","attrs","attrMap","Map","attr","rawName","normalizedName","has","originalRawName","get","eventRegex","handler","trim","value","exports","require","componentInfo","parseComponentMarkdown","map","version","slots","slot","externalClasses","externalClass","dataStructures","structure","fields","field","loadComponentDoc","context","log","selector","language","scheme","subscriptions","registerCompletionItemProvider","registerHoverProvider","actualComponentName","possiblePaths","path","resolve","__dirname","docPath","possiblePath","fs","existsSync","warn","content","readFileSync","extractTableSection","concat","extractDataStructures","split","v","undefined","promises","readFile","sectionTitle","escape","s","sliceTable","src","from","end","lines","l","slice","cell","_","arr","row","pascal","w","charAt","m","pipe","dataStructureRegex","structureName","cells","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","registerAll"],"sourceRoot":""}